Цель: Чётко описать условия и требования для проекта в виде чек-листа, ориентированного на лабораторные из прикреплённых условий.

1. Basic REST service

Создать Spring Boot приложение с модулем library-service.

Реализовать REST API для основных сущностей: Book, Copy, User, Loan, Fine.

Эндпоинты (пример):

GET /api/books — список (с пагинацией/фильтрацией)

GET /api/books/{id}

POST /api/books — добавить книгу

PUT /api/books/{id} — обновить

DELETE /api/books/{id}

POST /api/loans — выдать копию (тело содержит userId и copyId)

POST /api/loans/{id}/return — вернуть копию

Использовать DTO и маппинг между Entity и DTO (например, MapStruct или ручной mapper).

Документировать API через OpenAPI/Swagger.

2. JPA (Hibernate / Spring Data)

Подключить реляционную БД (H2 для dev, PostgreSQL для production).

Моделировать минимум 5 сущностей (см. idea.txt).

Использовать корректные аннотации: @Entity, @Table, @Id, @JoinColumn, @OneToMany, @ManyToOne, @ManyToMany (если есть Authors/Tags).

Реализовать CRUD репозитории через Spring Data JPA.

Показать и объяснить выбор CascadeType и FetchType для связей.

Продемонстрировать и решить проблему N+1 (через @EntityGraph или join fetch).

3. Data caching

Кешировать популярные запросы: топ-10 книг, результаты поиска по ISBN/названию.

Использовать Spring Cache (например, caffeine/ehcache/redis) — можно начать с ConcurrentHashMap/ Caffeine.

Реализовать корректный equals()/hashCode() для ключей кеша при необходимости.

Поддерживать пагинацию в запросах.

4. Error logging/handling

Ввести глобальный обработчик ошибок @ControllerAdvice.

Валидация входных данных через @Valid и DTO-валидацию.

Логирование через Logback + AOP-аспект (время вызова методов сервисов, вход/выход).

Обрабатывать бизнес-исключения (например, CopyNotAvailableException) и возвращать понятные HTTP-коды и тело ошибки.

5. Batch data processing & Testing

Реализовать batch-задачу (Spring Batch / Scheduled): ночной расчёт штрафов по просроченным выдачам и генерация Fine записей.

Пример bulk-операции: массовая загрузка каталога книг (POST со списком объектов).

Использовать Stream API/Optional в сервисном слое.

Покрыть сервисы unit-тестами (Mockito) и интеграционными тестами (Spring Boot Test, Testcontainers опционально).

6. Concurrency

Реализовать асинхронную выдачу/резервацию через @Async и возвращать CompletableFuture (либо использовать синхронный контроллер, но показать сервис async).

Обеспечить потокобезопасность выдачи копии: демонстрация optimistic locking (@Version) и/или pessimistic locking (@Lock(PESSIMISTIC_WRITE) в репозитории).

Написать тест, моделирующий race condition (многопоточные вызовы) и показать защиту.

7. Client

Требования к SPA: страница поиска/каталога, страница детальной карточки книги, личный кабинет для пользователя (список выданных книг, штрафов), форма для возвращения/продления.

Клиент работает с разработанным API (CORS, авторизация простая — mock JWT или сессии).

8. Deploy

Подготовить Dockerfile для сервиса и docker-compose (с БД, optional: redis).

Развернуть на бесплатном PaaS (например, Render, Railway, Fly — выбрать доступный). Указать шаги деплоя и что важно проверять (migrations, env variables).

Настроить CI в GitHub Actions: сборка, тесты, docker build, push, deploy.
